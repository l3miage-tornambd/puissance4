export const dataTests = {"userMail":"alexandre.demeure@univ-grenoble-alpes.fr","version":63,"mutants":[{"op":"isValid","comment":"no 2 winners","code":"function anonymous(state\n) {\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n}","body":"\n\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"errors in reverse priority order","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"too much tokens <-> not turn of Pi","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0], [1, -1], [1, 1], [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 >= nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 >= nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"missing direction [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        // [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Mising direction [1, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"Missing direction [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >=4    --->   >4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"winnercond >= 3","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 3;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"bad column number (-1)","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c - 1} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 > nbP2 /*+ 1*/","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 /*+ 1*/)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP2 > nbP1 + 1","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length > 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1 + 1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"col >= 6","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP1 = nb(state, \"P1\");\n    const nbP2 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"isValid","comment":"nbP1 <-> nbP2","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function nb(state, p) {\n        return state.grid.reduce((nb, L) => nb + L.reduce((n, c) => c === p ? 1 + n : n, 0), 0);\n    }\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    const nbP2 = nb(state, \"P1\");\n    const nbP1 = nb(state, \"P2\");\n    const i = state.grid.findIndex(L => L.length >= 6) + 1;\n    if (i > 0) {\n        const c = i;\n        return { valid: false, reason: `column ${c} has too much tokens` };\n    }\n    if (nbP1 > nbP2 + 1)\n        return { valid: false, reason: \"too much token for P1\" };\n    if (nbP2 > nbP1)\n        return { valid: false, reason: \"too much token for P2\" };\n    if (nbP1 === nbP2 + 1 && state.turn === \"P1\")\n        return { valid: false, reason: \"not the turn of P1\" };\n    if (nbP1 === nbP2 && state.turn === \"P2\")\n        return { valid: false, reason: \"not the turn of P2\" };\n    if (winnerCond(state, p => p === \"P1\") === \"P1\"\n        && winnerCond(state, p => p === \"P2\") === \"P2\") {\n        return { valid: false, reason: `There cannot be two winners` };\n    }\n    return { valid: true };\n\n","args":["state"]},{"op":"winner","comment":"nb > 4","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb > 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing [1, 0]","code":"function anonymous(state\n) {\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        // [1, 0], \n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, -1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        // [1, -1], \n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [1, 1], ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        // [1, 1], \n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"Missing  [0, 1]","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        // [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length < 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"<= 6 ? \"DRAW\"","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length <= 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"winner","comment":"L.length === 6 ? \"DRAW\" ","code":"function anonymous(state\n) {\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n}","body":"\n\n    const directions = [\n        [1, 0],\n        [1, -1],\n        [1, 1],\n        [0, 1]\n    ];\n    function winnerCond(state, f) {\n        let player;\n        if (state.grid.find((L, col) => L.find((token, line) => f(token) && directions.find(([dc, dl]) => {\n            var _a;\n            // 4 same in that direction, from that position\n            let c = col + dc;\n            let l = line + dl;\n            let nb = 1;\n            player = state.grid[col][line];\n            while (((_a = state.grid[c]) === null || _a === void 0 ? void 0 : _a[l]) === player) {\n                c += dc;\n                l += dl;\n                nb++;\n            }\n            return nb >= 4;\n        })))) {\n            return player;\n        }\n        return !state.grid.find(L => L.length === 6) ? \"DRAW\" : \"no winner yet\";\n    }\n    return winnerCond(state, () => true);\n\n","args":["state"]},{"op":"play","comment":"COL.length > 6","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (COL === undefined) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length > 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column  virgule","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 7) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 0 || column > 6 || !Number.isInteger(column)","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 0 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"column < 1 || column > 6 || !Number.isInteger(column) ","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (column < 1 || column > 6 || !Number.isInteger(column)) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P1","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"always P2","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: \"P2\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"no turn change","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn,\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong token","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== c ? P : [...P, state.state.turn === \"P1\" ? \"P2\" : \"P1\"])\n        }\n    };\n\n","args":["state","column"]},{"op":"play","comment":"wrong column","code":"function anonymous(state,column\n) {\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n}","body":"\n\n    const c = column - 1;\n    const COL = state.grid[c];\n    if (!COL) {\n        return { success: false, reason: \"no such column\" };\n    }\n    if (COL.length >= 6) {\n        return { success: false, reason: \"column is full\" };\n    }\n    return {\n        success: true,\n        state: {\n            turn: state.turn === \"P1\" ? \"P2\" : \"P1\",\n            grid: state.grid.map((P, i) => i !== (c + 1) ? P : [...P, state.turn])\n        }\n    };\n\n","args":["state","column"]}],"suites":[{"label":"Tests centrs sur isValid","LtestIds":["9zz2MWHIDHnricejPYEG","zahqfNcLkAAp0Ory4Buc","vkPi4GpRL1LrmTRh3TSg","FyWP3BUb13yHI7CIQV8o","DUyhPA9v5Zvr9i6RDZ7h","BGOU33xCIRtZW6CB3EQP","FEnVgChU97fxlV4VYDe0","SxbbgMi2augHXTfK3T8C","qF0mYupPvMVSaYCW39aD","fu67DJlcPjyvOCri6UPg","31YAoX2NI8suoAfqEwKU","kkE7IxyRo472Ufj4LaNe","JjiR4uAJeN3QI8I8nIxE","hnNcFB6qkdi5WGnIb4uJ","BkokGCD2kKJzQPYlmMIs","WkozxK73wvLURpOAX1QF","fzcWNGNDdT5lk52YAAys","Nm2sEVS2ipHTajEGrctk","afAsUkY0VpkRK9KTWFQT"],"id":"CLtMNpXwwUuXorvRyWtK","tests":[{"comment":"P1 at start","op":"isValid","id":"9zz2MWHIDHnricejPYEG","expect":{"valid":true},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}]},{"id":"zahqfNcLkAAp0Ory4Buc","expect":{"reason":"not the turn of P2","valid":false},"op":"isValid","result":{"valid":true},"pass":true,"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P2"}],"comment":"P2 at start is invalid (not the turn of P2)"},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2","P1"],[],[],[],[],[],[]],"turn":"P1"}],"op":"isValid","comment":"column 1 overload","id":"vkPi4GpRL1LrmTRh3TSg","expect":{"reason":"column 1 has too much tokens","valid":false}},{"expect":{"valid":false,"reason":"column 2 has too much tokens"},"op":"isValid","id":"FyWP3BUb13yHI7CIQV8o","params":[{"grid":[["P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P2"}],"comment":"column 2 overload","result":{"reason":"column 1 has too much tokens","valid":false},"pass":true},{"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],[],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"pass":true,"comment":"column 3 overload","result":{"reason":"column 2 has too much tokens","valid":false},"op":"isValid","id":"DUyhPA9v5Zvr9i6RDZ7h","expect":{"valid":false,"reason":"column 3 has too much tokens"}},{"pass":true,"op":"isValid","result":{"valid":false,"reason":"column 3 has too much tokens"},"expect":{"reason":"column 4 has too much tokens","valid":false},"id":"BGOU33xCIRtZW6CB3EQP","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1","P2","P1","P2","P1"],[],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"comment":"column 4 overload"},{"result":{"reason":"column 4 has too much tokens","valid":false},"expect":{"reason":"column 5 has too much tokens","valid":false},"op":"isValid","comment":"column 5 overload","pass":true,"id":"FEnVgChU97fxlV4VYDe0","params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1","P2","P1","P2","P1"],[],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}]},{"comment":"column 6 overload","expect":{"reason":"column 6 has too much tokens","valid":false},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1"],["P2","P1","P2","P1"],["P1","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}],"op":"isValid","result":{"reason":"column 5 has too much tokens","valid":false},"pass":true,"id":"SxbbgMi2augHXTfK3T8C"},{"id":"qF0mYupPvMVSaYCW39aD","pass":true,"result":{"valid":false,"reason":"column 6 has too much tokens"},"op":"isValid","comment":"column 7 overload","expect":{"valid":false,"reason":"column 7 has too much tokens"},"params":[{"grid":[["P1","P2","P1","P2"],["P2","P1","P2"],["P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2","P1"]],"turn":"P1"}]},{"op":"isValid","pass":true,"id":"fu67DJlcPjyvOCri6UPg","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"Not the turn of P1","expect":{"reason":"not the turn of P1","valid":false},"result":{"reason":"column 7 has too much tokens","valid":false}},{"op":"isValid","id":"31YAoX2NI8suoAfqEwKU","expect":{"reason":"not the turn of P2","valid":false},"result":{"valid":false,"reason":"There cannot be two winners"},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"comment":"Not the turn of P2","pass":false},{"expect":{"reason":"There cannot be two winners","valid":false},"pass":true,"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"reason":"not the turn of P2","valid":false},"op":"isValid","id":"kkE7IxyRo472Ufj4LaNe","comment":"There cannot be 2 winners"},{"id":"JjiR4uAJeN3QI8I8nIxE","comment":"There cannot be 2 winners (simple)","op":"isValid","pass":true,"params":[{"grid":[[],["P1"],["P1","P1"],["P1","P1","P1","P2"],["P2","P2","P2","P1"],["P2","P2"],["P2"]],"turn":"P1"}],"result":{"reason":"There cannot be two winners","valid":false},"expect":{"reason":"There cannot be two winners","valid":false}},{"result":{"valid":false,"reason":"There cannot be two winners"},"expect":{"reason":"There cannot be two winners","valid":false},"pass":true,"comment":"There cannot be 2 winners (simple 2 )","id":"hnNcFB6qkdi5WGnIb4uJ","op":"isValid","params":[{"grid":[["P2","P2"],["P1","P1"],["P1","P1","P2","P1"],["P1","P1","P1","P2","P1"],["P2","P1","P2"],["P2","P2"],["P2"]],"turn":"P2"}]},{"expect":{"reason":"There cannot be two winners","valid":false},"id":"BkokGCD2kKJzQPYlmMIs","op":"isValid","params":[{"turn":"P2","grid":[["P2"],["P2"],["P2"],["P2"],[],["P1"],["P1","P1","P1","P1"]]}],"comment":"no two winners (P2 first winner to be detected)"},{"comment":"Too much token for P1(P2 turn)","op":"isValid","id":"WkozxK73wvLURpOAX1QF","expect":{"valid":false,"reason":"too much token for P1"},"result":{"exec":"success","returns":{"valid":false,"reason":"not the turn of P2"}},"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true},{"result":{"returns":{"valid":false,"reason":"too much token for P1"},"exec":"success"},"expect":{"valid":false,"reason":"too much token for P1"},"id":"fzcWNGNDdT5lk52YAAys","comment":"Too much token for P1(P1 turn)","pass":true,"op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2","P1","P1"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2","P1"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P1"}},"comment":"Too much token for P2(P1 turn)","expect":{"valid":false,"reason":"too much token for P2"},"pass":true,"id":"Nm2sEVS2ipHTajEGrctk","op":"isValid","params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"params":[{"grid":[["P1","P1","P1","P1","P2"],["P2","P1","P2","P2"],["P2","P1","P2","P1"],["P1","P2","P2","P1"],["P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"expect":{"valid":false,"reason":"too much token for P2"},"id":"afAsUkY0VpkRK9KTWFQT","pass":true,"comment":"Too much token for P2(P2 turn)","result":{"exec":"success","returns":{"valid":false,"reason":"too much token for P2"}},"op":"isValid"}]},{"id":"Iokl5GpxtANX776ava1K","label":"Tests centrs sur winner","LtestIds":["glLaSQXbmUmgBmp6r2Mm","syiCwg8OD3K1W9EF92t9","kW4LcQzWEq6X00x7HBO5","TKHBHQcld9qDMXYQPj7q","5FOBGLPXH8u8QIIX6G0V","beZzzcq4SOmoXL0oGu6w","LuHz9ZxboUtXSIWigbBK","8ujgWEKhQzj6zjuyXSrw","batpdJsyIgc43I7q6xJC","MZAKmTYHM7ilFnG8jvy7","HeBTqTGBhTX1mD2MS5Y0","b92FbWdyOFIRT9j4H1x4","3PLGMtvnuwx2XtWjdl82","wBa7XMsYYhuUE07uxMsj","pcVytVFoXLDk5eQDoaXy","tGMb50UQ2JRMiXRnZOgr","9yWW3X0eQ1MagqBZ0Kwj","s9tb4tbHC18IMnq8Qv1F","Vm2yyQtmdHg5XhKkrIo8","2EozqANDNIsWdZt0rx84"],"tests":[{"comment":"First and last column full, no winner yet","id":"glLaSQXbmUmgBmp6r2Mm","expect":{"valid":true},"op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],[],[],[],[],[],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}]},{"id":"syiCwg8OD3K1W9EF92t9","op":"winner","comment":"no winner at beginning","expect":"no winner yet","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"}]},{"op":"isValid","comment":"valid full grid ","pass":true,"result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true},"id":"kW4LcQzWEq6X00x7HBO5"},{"id":"TKHBHQcld9qDMXYQPj7q","expect":"DRAW","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"valid":true},"comment":"valid full grid DRAW","pass":true,"op":"winner"},{"expect":{"valid":true},"pass":true,"id":"5FOBGLPXH8u8QIIX6G0V","op":"isValid","comment":"P1 win is valid (horizontal)","result":"DRAW","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}]},{"op":"winner","expect":"P1","id":"beZzzcq4SOmoXL0oGu6w","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P2"],["P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P2"}],"pass":true,"comment":"P1 win  (horizontal)","result":{"valid":true}},{"result":"P1","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win  (horizontal)","op":"winner","id":"LuHz9ZxboUtXSIWigbBK","expect":"P2","pass":true},{"result":"P2","pass":true,"id":"8ujgWEKhQzj6zjuyXSrw","comment":"P2 win is valid  (horizontal)","op":"isValid","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2"],["P1","P2","P1","P1"],["P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"expect":{"valid":true}},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"result":{"valid":true},"comment":"P2 win is valid  (North-East)","pass":true,"expect":{"valid":true},"op":"isValid","id":"batpdJsyIgc43I7q6xJC"},{"id":"MZAKmTYHM7ilFnG8jvy7","result":{"valid":true},"expect":"P2","pass":true,"op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P1","P2","P1","P1"],["P2","P1","P2"],["P1","P2","P1","P2","P1","P1"],["P1","P2","P1","P2","P2"],["P1","P2","P1","P2","P1","P2"]],"turn":"P1"}],"comment":"P2 win  (North-East)"},{"id":"HeBTqTGBhTX1mD2MS5Y0","expect":{"valid":true},"op":"isValid","comment":"P1 win is valid (North-East)","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"result":"P2"},{"expect":"P1","result":{"valid":true},"op":"winner","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2"],["P2","P1","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P2","P1","P2","P1","P1"]],"turn":"P2"}],"pass":true,"id":"b92FbWdyOFIRT9j4H1x4","comment":"P1 win (North-East)"},{"op":"winner","comment":"P1 win (South-East)","result":"P1","expect":"P1","id":"3PLGMtvnuwx2XtWjdl82","pass":true,"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}]},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P1","P2","P1","P2","P2","P2"],["P2","P1","P2","P1"],["P2","P1","P1","P2","P1"],["P1","P2","P2","P1"],["P1","P2","P1","P2","P1"],["P1","P1","P2"]],"turn":"P2"}],"expect":{"valid":true},"result":{"valid":true},"op":"isValid","pass":true,"comment":"P1 win is valid (South-East)","id":"wBa7XMsYYhuUE07uxMsj"},{"id":"pcVytVFoXLDk5eQDoaXy","result":{"valid":true},"pass":true,"op":"isValid","expect":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}],"comment":"P2 win is valid (South-East)"},{"id":"tGMb50UQ2JRMiXRnZOgr","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"pass":true,"op":"isValid","result":{"valid":true},"expect":{"valid":true},"comment":"P1 win is valid (Vertical)"},{"pass":true,"op":"winner","id":"9yWW3X0eQ1MagqBZ0Kwj","result":{"valid":true},"params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2"]],"turn":"P2"}],"expect":"P1","comment":"P1 win (Vertical)"},{"id":"s9tb4tbHC18IMnq8Qv1F","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"expect":{"valid":true},"op":"isValid","pass":true,"result":"P1","comment":"P2 win is valid (Vertical)"},{"id":"Vm2yyQtmdHg5XhKkrIo8","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1","P1"],["P2","P1","P2","P1"],["P2","P1","P1","P1"],["P1","P2","P2"],["P1","P2","P1","P2","P2"],["P1","P2","P2","P2","P2"]],"turn":"P1"}],"pass":true,"result":{"valid":true},"comment":"P2 win (Vertical)","expect":"P2","op":"winner"},{"result":{"valid":true},"expect":"P2","comment":"P2 win (South-East)","pass":true,"op":"winner","id":"2EozqANDNIsWdZt0rx84","params":[{"grid":[["P1","P2","P1","P2","P1"],["P1","P2","P1"],["P2","P1","P2","P1","P2"],["P2","P1","P1","P2","P1"],["P1","P2","P2"],["P1","P2","P1","P2"],["P1","P2","P2"]],"turn":"P1"}]}]},{"LtestIds":["b4kZF25jBSAuBzFN2qXJ","qcfoC7J2Xuyco68urGt5","R2CYLCliEJ6NMzhwinXP","yChU1qBNQNgh6JQ6WvWH","iCqK3kWJzOMsJ2sc8T9h","Q27G8Ha2dR9bYTvUoL6M","ID1QEDyJelNSuQX31wsq","wrhW8AJ3bqGfIBraGO7E","wyjsQEs96yujowPxSvyK","phjLRjzsSpDMaFN9TPxm","QAU8unGFzPlAePNGcj7B","9Y6TAKJm1vlKbkfN5TcA","THzFebM3mnvxc8eWE62A","7sPqLgqlM5YuZmpT8o54"],"label":"Tests centrs sur play","id":"vLSmQjtYL408m9TPGq5G","tests":[{"id":"b4kZF25jBSAuBzFN2qXJ","op":"play","expect":{"state":{"grid":[["P1"],["P2"],[],["P1"],[],[],[]],"turn":"P2"},"success":true},"comment":"second coup sur 4","params":[{"grid":[["P1"],["P2"],[],[],[],[],[]],"turn":"P1"},4]},{"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},1],"op":"play","id":"qcfoC7J2Xuyco68urGt5","expect":{"state":{"grid":[["P1"],[],[],[],[],[],[]],"turn":"P2"},"success":true},"comment":"play at 1"},{"id":"R2CYLCliEJ6NMzhwinXP","comment":"impossible to play at 2.1","expect":{"reason":"no such column","success":false},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},2.1],"op":"play"},{"id":"yChU1qBNQNgh6JQ6WvWH","params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},0],"expect":{"reason":"no such column","success":false},"op":"play","comment":"impossible to play at 0"},{"params":[{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1"]],"turn":"P2"},7],"comment":"possible to play at 7","op":"play","expect":{"success":true,"state":{"grid":[["P1"],["P1"],["P2","P2","P1"],["P1"],["P2","P2"],["P1"],["P2","P1","P2"]],"turn":"P1"}},"id":"iCqK3kWJzOMsJ2sc8T9h"},{"op":"play","id":"Q27G8Ha2dR9bYTvUoL6M","comment":"Impossible to play at 8","expect":{"reason":"no such column","success":false},"params":[{"grid":[[],[],[],[],[],[],[]],"turn":"P1"},8]},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"comment":"Full grid is valid","id":"ID1QEDyJelNSuQX31wsq","result":{"success":false,"reason":"no such column"},"pass":true,"op":"isValid","expect":{"valid":true}},{"id":"wrhW8AJ3bqGfIBraGO7E","result":{"valid":true},"expect":"DRAW","pass":true,"comment":"Draw with full grid and player 1 turn","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"}],"op":"winner"},{"op":"play","result":"DRAW","expect":{"reason":"column is full","success":false},"pass":true,"comment":"Draw grid, cannot play at 1","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},1],"id":"wyjsQEs96yujowPxSvyK"},{"expect":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 2","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},2],"pass":true,"id":"phjLRjzsSpDMaFN9TPxm","op":"play","result":{"reason":"column is full","success":false}},{"expect":{"reason":"column is full","success":false},"id":"QAU8unGFzPlAePNGcj7B","comment":"Draw grid, cannot play at 3","op":"play","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},3],"result":{"reason":"column is full","success":false},"pass":true},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},5],"pass":true,"op":"play","result":{"reason":"column is full","success":false},"expect":{"success":false,"reason":"column is full"},"id":"9Y6TAKJm1vlKbkfN5TcA","comment":"Draw grid, cannot play at 5"},{"result":{"success":false,"reason":"column is full"},"comment":"Draw grid, cannot play at 6","id":"THzFebM3mnvxc8eWE62A","params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},6],"expect":{"success":false,"reason":"column is full"},"op":"play","pass":true},{"params":[{"grid":[["P1","P2","P1","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P1","P1","P2","P2","P2","P1"],["P2","P2","P1","P1","P1","P2"],["P1","P1","P2","P2","P1","P2"],["P2","P1","P2","P1","P2","P1"],["P2","P1","P1","P1","P2","P2"]],"turn":"P1"},7],"comment":"Draw grid, cannot play at 7","id":"7sPqLgqlM5YuZmpT8o54","result":{"reason":"column is full","success":false},"pass":true,"op":"play","expect":{"success":false,"reason":"column is full"}}]}],"canObserve":[],"evals":[63,{"play":[12,12],"isValid":[30,30],"winner":[11,11]},{"play":[9,9],"isValid":[14,14],"winner":[7,7]}]}
